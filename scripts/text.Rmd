---
title: "Methylation array analysis workflow"
author: "Belinda Phipson and Jovana Maksimovic"
date: "3/30/2016"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#Introduction
DNA methylation, the addition of a methyl group to a CG dinucleotide of the DNA, is the most extensively studied epigenetic mark due to its role in both development and disease (REF). Although DNA methylation can be measured in several ways, the epigenetics community has enthusiastically embraced the Illumina HumanMethylation450 (450k) array as a cost-effective way to assay methylation across the human genome since its realease in 2011. Illumina has recently increased the genomic coverage of the platform to >850,000 sites with the release of their MethylationEPIC (850k) array. As methylation arrays are likely to remain integral for measuring methylaiton for the forseeable future, it is necessary to provide robust workflows for methylation array analysis.  

Measurement of DNA methylation by Infinium technology (Infinium I) was first employed by Illumina on the HumanMethylation27 (27k) array (REF), which measured methylation at approximately 27,000 CpGs, primarily in gene promoters. Like bisulfite sequencing, the Infinium assay detects methylation status at single base resolution. However, due to its relatively limited coverage the array platform was not truly considered "genome-wide" until the arrival of the 450k array. The 450k array increased the genomic coverage of the platform to over 450,000 gene-centric sites by combining the original Infinium I assay with the novel Infinium II. Both assay types employ 50bp probes that query a [C/T] polymorphism created by bisulfite conversion of unmethylated cytosines in the genome, however, the Infinium I and II assays differ in the number of beads required to detect methylation at a single locus. Infinium I uses 2 bead types per CpG, 1 for each the methylated and unmethylated states. In contrast, the Infinium II design uses 1 bead type and the methylated state is determined at the single base extension step after hybridization (Figure). The 850k array also uses a combination of the Infinium I and II assays but achieves additional coverage by increasing the size of each array; a 450k slide contains 12 arrays whilst the 850k has only 8. 

Regardless of the Illumina array version, for each CpG, there are 2 measurements: a methylated intensity and an unmethylated intensity. These intensity values can then be used to determine the proportion of methylation at each CpG locus. Methylation levels are commonly reported as either beta values ($\beta = Mval/(M + U + alpha)$) or M-values ($M-value = log2(M/U)$). Beta values are generally preferable for decribing the level of methylation at a locus or presenting it graphically because percentage methylation is easily interpretable. However, due to their statistical properties, M-values are more appropriate for statistical testing (REF).

In this workflow, we will provide examples of the steps involved in analysing methylation array data using R (REF) and Bioconductor (REF), including: quality control, filtering, normalization, data exploration and probe-wise differential methylation analysis. We will also cover other approaches such as differential methylation analysis of regions, differential variability analysis and gene ontology analysis. Finally, we will provide some examples of useful ways to visualise methylation array data.

```{r, echo=FALSE, results='hide', cache=TRUE}
dataDirectory = "/mnt/storage/shared/BioinfoSummer2015/450kAnalysisWorkshop/data/"
targets = read.450k.sheet(dataDirectory, pattern="SampleSheet.csv")
```

# Differential methylation analysis
To demonstrate the various aspects of analysing methylation data, we will be using a small, publicly available 450k methylation dataset (REF). The dataset contains 10 samples in total; there are 4 different sorted T-cell types (`r unique(targets$Sample_Group)`), collected from 3 different individuals (`r unique(targets$Sample_Source)`). For details describing sample collection and preparation, see Zhang, Maksimovic et al. (2012)(REF). An additional sample from an unrelated study (REF) is also included to illustrate approaches for identifying and excluding poor quality samples. 

```{r}
targets[,c("Sample_Name","Sample_Source", "Sample_Group")]
```

There are several R Bioconductor packages available that have been developed for analysing methylation array data, including *minfi*(REF), *missMethyl*(REF), *wateRmelon*(REF), *methylumi*(REF), *ChAMP*(REF) and *charm*(REF). Some of the packages, such as *minfi* and *methylumi* include a framework for reading in the raw data from IDAT files and various specialised objects for storing and manipulating the data throughout the course of an analysis. Other packages provide specialised analysis methods for normalisation and statistical testing that rely on either *minfi* or *methylumi* objects. It is possible to convert between *minfi* and *methylumi* data types, however, this is not always trivial. Thus, it is advisable to consider the methods that you are interested in using in your analysis and the data types that are most appropriate. Another popular method for analysing methylation array data is *limma*(REF), which was originally developed for expression microarray analysis. As *limma* operates on a matrix of values, it is easily applied to data loaded using any framework that can be converted to a matrix.         

We will begin with an example of a **probe-wise** methylation analysis using *minfi* and *limma*. By **probe-wise** analysis we mean that we will obtain a moderated t-statistic and p-value for each individual CpG probe, which we can use to determine which individual CpGs are differentially methylated at some significance level for our comparisons of interest.

### Loading the data
It is useful to begin an analysis in R by loading all the package libraries that are likely to be required.
```{r, cache=TRUE}
# load packages required for analysis
library(limma)
library(minfi)
library(IlluminaHumanMethylation450kanno.ilmn12.hg19)
library(IlluminaHumanMethylation450kmanifest)
library(RColorBrewer)
library(missMethyl)
library(matrixStats)
library(minfiData)
library(Gviz)
library(DMRcate)
library(stringr)
```

*Minfi* provides the Illumina manifest as an R object which can easily be loaded into the environment. The manifest contains all of the annotation information for each of the CpG probes on the 450k array. This is useful for determining where any differentially methylated probes are located in a genomic context. 
```{r, cache=TRUE}
## get the 450k annotation data
ann450k = getAnnotation(IlluminaHumanMethylation450kanno.ilmn12.hg19)
head(ann450k)
```

The simplest way to read the raw methylation data into R is using the *minfi* function `read.450k.sheet`, along with the path to the IDAT files and sample sheet. The sample sheet is a CSV (comma-separated) file containing one line per sample, with a number of columns describing each sample (SUPP FILE). The format expected by the `read.450k.sheet` function is based on the sample sheet file that usually accompanies Illumina methylation array data. It is also very similar to the targets file described by the *limma* package. Reading the sample sheet into R creates a `data.frame` with one row for each sample and several columns. 
```{r, cache=TRUE}
# set up a path to the data directory 
dataDirectory = "/mnt/storage/shared/BioinfoSummer2015/450kAnalysisWorkshop/data/"

# read in the sample sheet for the experiment
targets = read.450k.sheet(dataDirectory, pattern="SampleSheet.csv")
targets
```

Now that we have imported the information about the nature and location of the data, we can read the raw intensity signals into R from the IDAT files. It can be useful to rename the samples with more descriptive names. 

```{r, cache=TRUE}
## read in the raw data from the IDAT files
rgSet = read.450k.exp(targets=targets)
rgSet

# give the samples descriptive names
targets$ID = paste(targets$Sample_Group,targets$Sample_Name,sep=".")
sampleNames(rgSet) = targets$ID
rgSet
```

### Quality control
One the data has been imported into R, we can evaluate its quality. Firstly, we need to calculate detection p-values. We can generate a detection p-value for every CpG in every sample, which is indicative of the quality of the signal. The method used by *minfi* to calculate detection p-values compares the total signal (M + U) for each probe to the background signal level, which is estimated from the negative control probes. Very small p-values are indicative of a reliable signal whilst probes with larger p-values (typically >0.01) should not be trusted.

Plotting the mean detection p-value for each sample will allow us to gauge the quality of the samples. Samples that have many failed probes will have relatively large mean detection p-values. 

```{r, cache=TRUE}
# calculate the detection p-values
detP = detectionP(rgSet)
head(detP)

# examine mean detection p-values across all samples to identify any failed samples
pal = brewer.pal(8,"Dark2")
par(mfrow=c(1,2))
barplot(colMeans(detP),col=pal[factor(targets$Sample_Group)],las=2,cex.names=0.8,
        ylab="Mean detection p-values")
abline(h=0.05,col="red")
legend("topleft",legend=levels(factor(targets$Sample_Group)),fill=pal,bg="white")

barplot(colMeans(detP),col=pal[factor(targets$Sample_Group)],las=2,cex.names=0.8,ylim=c(0,0.002),
        ylab="Mean detection p-values")
abline(h=0.05,col="red")
legend("topleft",legend=levels(factor(targets$Sample_Group)),fill=pal,bg="white")

```

The *minfi* `qcReport` function generates many other useful quality control plots. The *minfi* [vignette](http://bioconductor.org/packages/release/bioc/vignettes/minfi/inst/doc/minfi.pdf) describes the various plots in this report and how they should be interpreted. Generally, samples that look poor based on mean detection p-value will also look poor using other metrics and it is usually advisable to exclude them from further analysis.
```{r, eval=FALSE}
qcReport(rgSet, sampNames=targets$ID, sampGroups=targets$Sample_Group, pdf="qcReport.pdf")
```

Poor quality samples can be easily excluded from the analysis based on a detection p-value cutoff, for example >0.05. 
```{r, cache=TRUE}
# remove poor quality samples
keep = colMeans(detP) < 0.05
rgSet = rgSet[,keep]
targets = targets[keep,]
detP = detP[,keep]

rgSet

targets
```

### Normalization
To minimise the unwanted variation within and between samples, various data normalizations can be applied. Many different types or normalization have been developed for methylation arrays and it is beyond the scope of this tutorial to compare and contrast them all (REFS). Several methods have been built into *minfi* and can be directly applied within its framework, whilst others are *mthylumi*-specific of require custom data types (REFS). Although there is no one normalization that is universally considered best, a recent study has suggested that a good rule of thumb within the *minfi* framework is that the `preprocessFunnorm` function is most appropriate for datasets with global methylation differences such as cancer/normal or vastly different tissue types, whilst the `preprocessQuantile` function is more suited for datasets where you do not expect global differences between your samples, for example a single tissue (REF). As we are comparing different blood cell types, which are globally relatively similar, we will apply the `preprocessQuantile` method to our data. 

```{r, cache=TRUE}
# normalize the data
mSetSq = preprocessQuantile(rgSet) 

# create a MethylSet object from the raw data for plotting
mSetRaw = preprocessRaw(rgSet)

# visualise what the data looks like before and after normalization
par(mfrow=c(1,2))
densityPlot(rgSet, sampGroups = targets$Sample_Group,main="Raw")
densityPlot(getBeta(mSetSq), sampGroups = targets$Sample_Group,main="SQN")
```

### Data exploration
Multi dimensional scaling (MDS) plots are excellent for visualising data, and are usually one of the first kinds of plots you should make when exploring your data. It is based on principle componenents analysis and is an unsupervised method for looking at the similarities and differences between the various samples. Samples that are more similar to each other should cluster together, and samples that are very different should be further apart on the plot. Dimension 1 (or principle component 1) captures the greatest source of variation in the data, dimension 2 captures the second greatest source of variation in the data and so on.  Colouring in the data points or labels by known factors of interest can often highlight exactly what the greatest sources of variation are in the data. It is also possible to use MDS plots to decipher sample mix-ups.
```{r, cache=TRUE}
## MDS plots to look at largets sources of variation
par(mfrow=c(1,2))
plotMDS(getM(mSetSq), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)])
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)

plotMDS(getM(mSetSq), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Source)])
legend("topright",legend=levels(factor(targets$Sample_Source)),text.col=pal)
```

Examining the MDS plots of this dataset demonstrates that the largest source of variation dataset are the differences between individuals. Looking at the higher dimensions reveals that the differences between cell types are largely captures by the 3rd and 4th principal components. This type of information is useful, as we can include obvious sources of unwanted variation in our statistical model to account for them.  
```{r, cache=TRUE}
par(mfrow=c(1,3))
## Examine higher dimensions to look at other sources of variation
plotMDS(getM(mSetSq), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)], dim=c(1,3))
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)

plotMDS(getM(mSetSq), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)], dim=c(2,3))
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)

plotMDS(getM(mSetSq), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)], dim=c(3,4))
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)
```

### Filtering
Poor performing probes are generally filtered out prior to differential methylation analysis. As the signal from these probes is unreliable, by removing them we perform fewer statistical tests and thus incur a reduced multiple testing adjustment. We filter out probes that have failed in one or more samples based on detection p-value.    
```{r, cache=TRUE}
## remove any probes that have failed in one or more samples
detP = detP[match(featureNames(mSetSq),rownames(detP)),] # ensure probes are in the same order in the mSetSq and detP objects
keep = rowSums(detP < 0.01) == ncol(mSetSq) 
table(keep)

mSetSqFlt = mSetSq[keep,]
mSetSqFlt
```

Depending on the nature of your samples and your biological question you may also choose to filter out the probes from the X and Y chromosomes or probes that are known to have common SNPs at the CpG site. As the samples in this dataset all came from male donors, we will not be removing them as part of this analysis, however example code is provided below.
```{r, eval=FALSE}
## if your data infludes males and females, remove the sex chromosomes
keep = !(featureNames(mSetSqFlt) %in% ann450k$Name[ann450k$chr %in% c("chrX","chrY")])
table(keep)

mSetSqFlt = mSetSqFlt[keep,]
```

There is a function provided in *minfi* that provides a simple interface for the removal of probes with SNPs potentially affecting the CpG. YOu can either remove all probes affected by SNPs (defaault), or only those with minor allele frequencies greater than the value specified.  
```{r, cache=TRUE}
## remove probes with SNPs at CpG or SBE site
mSetSqFlt = dropLociWithSnps(mSetSqFlt)
```

We will also filter out probes that have shown to be cross-reactive, that is, probes that have been demonstrated to map to multiple places in the genome. This list was originally published by [Chen et al.](http://www.tandfonline.com/doi/abs/10.4161/epi.23470) in 2013 and can be downloaded directly from the author's [website](http://www.sickkids.ca/MS-Office-Files/Research/Weksberg%20Lab/48639-non-specific-probes-Illumina450k.xlsx).
```{r, cache=TRUE}
## exclude cross reactive probes 
xReactiveProbes = read.csv(file=paste(dataDirectory,"48639-non-specific-probes-Illumina450k.csv",sep=""),
                           stringsAsFactors=FALSE)
keep = !(featureNames(mSetSqFlt) %in% xReactiveProbes$TargetID)
table(keep)

mSetSqFlt = mSetSqFlt[keep,] 
mSetSqFlt
```

Once the data has been filtered and normalized, it is often useful to re-examine the MDS plots to see if the relationship between the samples has changed. It is apparent from the new MDS plots that much of the inter-individual variation has been removed as this is no longer the 1st principal component, likely due to the removal of the SNP-affected CpG probes. However, the samples do still cluster by individual in the 2nd dimension and thus a factor for indivdual should still be included in our model.  
```{r, cache=TRUE}
par(mfrow=c(1,2))
plotMDS(getM(mSetSqFlt), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)])
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)

plotMDS(getM(mSetSqFlt), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Source)])
legend("topright",legend=levels(factor(targets$Sample_Source)),text.col=pal)

par(mfrow=c(1,3))
## Examine higher dimensions to look at other sources of variation
plotMDS(getM(mSetSqFlt), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)], dim=c(1,3))
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)

plotMDS(getM(mSetSqFlt), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)], dim=c(2,3))
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)

plotMDS(getM(mSetSqFlt), top=1000, gene.selection = "common", col=pal[factor(targets$Sample_Group)], dim=c(3,4))
legend("topright",legend=levels(factor(targets$Sample_Group)),text.col=pal)
```

We can calculate M and $\beta$ values. As previously mentioned, M-values have nicer statistical properties and are thus better for use in statistical analysis of methylation data whilst $\beta$ values are easy to interpret and are thus better for displaying data. A detailed comparison of M and $\beta$ values was published by [Du et al.](http://www.biomedcentral.com/1471-2105/11/587) in 2010.  
```{r, cache=TRUE}
## calculate M-values for statistical analysis
mVals = getM(mSetSqFlt)
head(mVals)

bVals = getBeta(mSetSqFlt)
head(bVals)

par(mfrow=c(1,2))
densityPlot(bVals,sampGroups = targets$Sample_Group,main="Beta values")
densityPlot(mVals,sampGroups = targets$Sample_Group,main="M values")
```


### Probe-wise differential methylation analysis
The biological question of interest for for this particular dataset is to discover differentially methylated probes between the different cell types. However, as was apparent in the MDS plots, there is another factor that we need to take into account when we perform the statistical analysis. In the `targets` file, there is a column called `Sample_Source`, which refers to the individuals that the samples were collected from. In this dataset, each of the individuals contributes more than one cell type. For example, individual M28 contributes naive, rTreg and act_naive samples. Hence when we specify our design matrix, we need to include two factors: individual and cell type. This style of analysis is called a paired analysis; differences between cell types are calculated *within* each individual, and then these differences are summed *across* individuals to determine whether there is an overall significant difference in the mean methylation level for each CpG site.
```{r, cache=TRUE}
cellType = factor(targets$Sample_Group) # this is the factor of interest
individual = factor(targets$Sample_Source) # this is the individual effect that we need to account for

# use the above to create a design matrix
design = model.matrix(~0+cellType+individual, data=targets)
colnames(design) = c(levels(cellType),levels(individual)[-1])
  
fit = lmFit(mVals, design) ## fit the linear model
# create a contrast matrix for specific comparisons
contMatrix = makeContrasts(naive-rTreg,
                           naive-act_naive,
                           rTreg-act_rTreg,
                           act_naive-act_rTreg,
                           levels=design)
contMatrix

# fit the contrasts
fit2 = contrasts.fit(fit, contMatrix)
fit2 = eBayes(fit2)

# look at the numbers of DM CpGs at FDR < 0.05
summary(decideTests(fit2))

# get the table of results for the first contrast (naive - rTreg)
ann450kSub = ann450k[match(rownames(mVals),ann450k$Name),c(1:4,12:19,24:ncol(ann450k))]
DMPs = topTable(fit2, num=Inf, coef=1, genelist = ann450kSub)
head(DMPs)

```

The results of the analysis for the first comparison, naive vs. rTreg, are stored in the `DMPs` object. We can write this `data.frame` to a CSV file, which can be opened in Excel.

```{r, eval=FALSE}
write.table(DMPs, file="DMPs.csv", sep=",", row.names=FALSE)

```

It is always useful to plot the top differentially methylated CpG sites; it serves as a sanity check to ensure the results make sense. If the plots do not look as expected, it is usually an idication of an error in the code somewhere, or in setting up the design matrix. It is easier to interpret methylation on the $\beta$ value scale, so although we always perform analysis on the M-value scale, we usually visualise data on the $\beta$ value scale.
```{r, cache=TRUE}
par(mfrow=c(2,2))
sapply(rownames(DMPs)[1:4], function(cpg){
  plotCpg(bVals, cpg=cpg, pheno = targets$Sample_Group)
})

```

### Differential methylation analysis of regions
Although performing a *probe-wise* analysis is useful and informative, sometimes we are interested in knowing whether several proximal CpGs are concordantly differentially methylated, that is, we want to identify differentially methylated *regions*. There are several Bioconductor packages that have functions for identifing differentially methylated regions from 450k data. Some of the most widely used are the `bumphunter` function in [minfi](http://bioconductor.org/packages/release/bioc/html/minfi.html),  `dmrFind` in [charm](http://www.bioconductor.org/packages/release/bioc/html/charm.html) and `dmrcate` in  [DMRcate](https://www.bioconductor.org/packages/release/bioc/html/DMRcate.html). They are each based on different statistical methods. `bumphunter` and `dmrFind` can be quite slow unless you have the computer infrastructure to parallelise them as they use premutations to assign significance. In this workflow, we will perform an analysis using *DMRcate*. As it is based on *limma*, we can directly use the `design` and `contMatrix` we previously defined.

Firstly, our matrix of M-values is annotated with relevant information about the probes such as their genomic position, gene annotation, etc. By default, this is done using the `ilmn12.hg19` annotation, but this can be substituted for any argument compatible with the interface provided by the *minfi* package. The *limma* pipeline is then used for differential methylation analysis to calculate t-statistics.
```{r, cache=TRUE}
myAnnotation = cpg.annotate(mVals, datatype = "array", analysis.type="differential", design=design, contrasts = TRUE,
                             cont.matrix = contMatrix, coef="naive - rTreg")

str(myAnnotation)
```

We can then use the `dmrcate` function to look for differentially methylated regions. The main output table `DMRs$results` contains all of the regions found, along with their genomic annotations and p-values.
```{r, cache=TRUE}
DMRs = dmrcate(myAnnotation, lambda=1000, C=2)
head(DMRs$results)
```

The regions can be viewed using the `DMR.plot` function provided in the *DMRcate* package. 
```{r, cache=TRUE}
data(dmrcatedata)
results.ranges <- extractRanges(DMRs, genome = "hg19")

groups <- pal[1:length(unique(targets$Sample_Group))]
names(groups) <- levels(factor(targets$Sample_Group))
cols <- groups[as.character(factor(targets$Sample_Group))]
samps <- 1:nrow(targets)
par(mfrow=c(1,1))
DMR.plot(ranges=results.ranges, dmr=1, CpGs=bVals, phen.col=cols,
         pch=16, toscale=TRUE, plotmedians=TRUE, genome="hg19",samps=1:10)
```

### Customising your visualisations of methylation data
The *Gviz* package offers some powerful functionality for plotting methylation data in its genomic context. The package [vignette](https://bioconductor.org/packages/release/bioc/vignettes/Gviz/inst/doc/Gviz.pdf) is quite extensive and covers the various types of plots that can be produced using the *Gviz* framework. We will re-plot the top differentially methylated region from the *DMRcate* regional analysis to demonstrate the richness of the visualisations that can be created.

We will first set up the genomic region we would like to plot by extracting the genomic coordinates of the top differentially methylated region.

```{r, cache=TRUE}
gen = "hg19"
coords = strsplit2(DMRs$results$coord[1],":")
chrom = coords[1]
start = as.numeric(strsplit2(coords[2],"-")[1])
end = as.numeric(strsplit2(coords[2],"-")[2])
minbase = start - (0.25*(end-start))
maxbase = end + (0.25*(end-start))
```

Next, we will add some genomic annotations of interest such as the locations of CpG islands and DNAseI hypersensitive sites.
```{r, cache=TRUE}
# CpG islands
islandHMM = read.csv(paste(dataDirectory,"model-based-cpg-islands-hg19.txt",sep="/"),
                     sep="\t", stringsAsFactors =FALSE, header=TRUE)
head(islandHMM)

islandData = GRanges(seqnames = Rle(islandHMM$chr),
                     ranges = IRanges(islandHMM$start, end = islandHMM$end),
                    strand = Rle(strand(rep("*",nrow(islandHMM)))))
islandData = islandData[seqnames(islandData) == chrom &
                         (start(islandData) >= minbase & end(islandData) <= maxbase)] # this is to reduce the amount of data in memory
islandData

## DNAseI hypersensitive sites
dnase = read.csv(paste(dataDirectory,"wgEncodeRegDnaseClusteredV3.bed",sep="/"),
                 sep="\t",stringsAsFactors=FALSE,header=FALSE)
head(dnase)

dnaseData = GRanges(seqnames = dnase[,1],
                    ranges = IRanges(dnase[,2], end = dnase[,3]),
                    strand = Rle(rep("*",nrow(dnase))),
                    data = dnase[,5])
dnaseData = dnaseData[seqnames(dnaseData) == chrom &
                          (start(dnaseData) >= minbase & end(dnaseData) <= maxbase)] # this is to reduce the amount of data in memory
dnaseData

```

Now, set up the ideogram, genome and RefSeq tracks that will provide context for our methylation data. 
```{r, cache=TRUE}
iTrack = IdeogramTrack(genome = gen, chromosome = chrom, name="")
gTrack = GenomeAxisTrack(col="black", cex=1, name="", fontcolor="black")
rTrack = UcscTrack(genome = gen, chromosome = chrom, track = "refGene", from = minbase,
                            to = maxbase, trackType = "GeneRegionTrack", rstarts = "exonStarts",
                            rends = "exonEnds", gene = "name", symbol = "name2", transcript = "name",
                            strand = "strand", fill = "darkblue",stacking = "squish", name = "RefSeq",
                            showId=TRUE, geneSymbol=TRUE)
```

Ensure that the methylation data is ordered by chromosome and base position.
```{r, cache=TRUE}
ann450kOrd = ann450kSub[order(ann450kSub$chr,ann450kSub$pos),]
head(ann450kOrd)

bValsOrd = bVals[match(ann450kOrd$Name,rownames(bVals)),]
head(bValsOrd)
```

Create the data tracks using the appropriate track type for each data type.
```{r, cache=TRUE}
cpgData = GRanges(seqnames = Rle(ann450kOrd$chr),
                    ranges = IRanges(ann450kOrd$pos, end = ann450kOrd$pos),
                    strand = Rle(rep("*",nrow(ann450kOrd))),
                    betas = bValsOrd)
cpgsInDMR = subsetByOverlaps(cpgData,results.ranges[1])

methTrack = DataTrack(range=cpgsInDMR,
                     groups=targets$Sample_Group,genome = gen,chromosome = chrom, ylim=c(-0.05,1.05),
                     col=pal,type=c("a","p"), name="DNA Meth.\n(beta value)", background.panel="white",legend=TRUE,
                     cex.title=0.4,cex.axis=0.5,cex.legend=0.8)
islandTrack = AnnotationTrack(range=islandData, genome = gen, name = "CpG Is.", chromosome = chrom)
dmrTrack = AnnotationTrack(start=start, end=end, genome = gen, name = "DMR", chromosome = chrom)
dnaseTrack = DataTrack(range=dnaseData, genome = gen, name = "DNAseI", type="gradient",
                        chromosome = chrom)
```

Set up the track list and indicate the relative sizes of the different tracks. Finally, make the plot using the `plotTracks` function.
```{r, cache=TRUE}
tracks = list(iTrack,gTrack,methTrack,dmrTrack,islandTrack,dnaseTrack,rTrack)
sizes = c(2,2,5,2,2,2,3)
plotTracks(tracks, from = minbase, to = maxbase, showTitle = TRUE, add53 = TRUE, add35 = TRUE,
          grid=TRUE, lty.grid=3, sizes=sizes, length(tracks))

```

# Additional analyses
## Gene ontology testing

Once you have performed a differential methylation analysis, there may be a very long list of significant CpG sites to interpret. One question a researcher may have is, "in which gene pathways do significant CpGs appear?". Sometimes it is easy to link the top differentially methylated CpGs to genes that make sense in terms of the cell types/samples being studied, but there can be many more thousands of CpGs significantly differentially methylated. In order to get an idea of the biological processes that the significant CpGs may be involved in, we can perform gene ontology testing with the `gometh` function in the *missMethyl* package.

Let us consider the first comparison, naive vs rTreg, with the results of the analysis in the `DMPs` table. The `gometh` function takes as input a character vector of the names (e.g. cg20832020) of the significant CpG sites, and optionally, a character vector of all CpGs tested. This is recommended if you have performed quite a lot of filtering of the CpGs before analysis. In the `DMPs` table, the `Name` column corresponds to the CpG name. We will select all CpG sites that have adjusted p-value of less than 0.05.

```{r, cache=TRUE}
## Get the significant CpG sites at less than 5% FDR
sigCpGs = DMPs$Name[DMPs$adj.P.Val<0.05]
## First 10 significant CpGs
sigCpGs[1:10]
## Total number of significant CpGs at 5% FDR
length(sigCpGs)
## Get all the CpG sites used in the analysis to form the background
all = DMPs$Name
## Total number of CpG sites tested
length(all)
```

The `gometh` function takes into account the varying numbers of CpGs associated with genes on the Illumina methylation arrays. For the 450k array, the numbers of CpGs mapping to genes can vary from as few as 1 to as many as 1200. The genes that have more CpGs associated with them will have a higher probability of being identified as differentially methylated compared to genes with fewer CpGs. We can look at the bias in the data by specifying `plot=TRUE` in the call to `gometh`.

```{r, cache=TRUE}
par(mfrow=c(1,1))
gst <- gometh(sig.cpg=sigCpGs, all.cpg=all, plot.bias=TRUE)
```

The `gst` object is a `data.frame` with each row corresponding to the GO category being tested. The top 20 gene ontology categories can be displayed using the `topGO` function:

```{r, cache=TRUE}
## Top 20 GO categories
topGO(gst)
```

Here we can see lots of GO categories corresponding to immune system and T cell processes, which makes sense as the cell types being studied form part of the immune system. The total number of significant GO categories, adjusted for multiple testing, is `r sum(gst$FDR<0.05)`.

For a more generalised version of gene set testing methylation data where the user can specify the gene set to be tested, the `gsameth` function can be used. To display the top 20 pathways, `topGSA` can be called. `gsameth` accepts a single gene set, or a list of gene sets. The gene identifiers in the gene set must be Entrez Gene IDs. To demonstrate `gsameth`, we are using the curated genesets (C2) from the Broad Institute Molecular signatures [database](http://software.broadinstitute.org/gsea/msigdb). These can be donwloaded as an RData oject from the WEHI BIoinformatics [website](http://bioinf.wehi.edu.au/software/MSigDB/).  

```{r, cache=TRUE}
source("/home/jovanam/jovanam/R_packages/gsameth.R")
source("/home/jovanam/jovanam/R_packages/gometh.R")
source("/home/jovanam/jovanam/R_packages/kegga.R")

load(paste(dataDirectory,"human_c2_v5.rdata",sep=""))
gsa <- gsameth(sig.cpg=sigCpGs, all.cpg=all, collection=Hs.c2)

topGSA(gsa)
```

## Differential variability
Rather than testing for differences in mean methylation, we may be interested in testing for differences between group variances. For example, it has been hypothesised that highly variable CpGs in cancer are important for tumour progression. Hence we may be interested in CpG sites that are consistently methylated in one group, but variably methylated in another group. In general we recommend at least 10 samples in each group for testing differential variability in order to get a good estimate of the variance. It is more tricky to accurately estimate variances as opposed to means, so you generally need a larger sample size for testing differences in group variances as opposing to testing differences in group means. For the purpose of this workshop, we won't worry about this sample size issue.

The way we specify which groups we are interested in testing is a little bit different to the way you specify a model in `limma` for differential methylation, particularly if you fit an intercept model. For our data, we have set up a design matrix without an intercept term, and we will specify which groups we want to test for differential variability in a contrasts statement. We can use the same design matrix that we set up for testing differential methylation.
```{r, cache=TRUE}
# plan on changing the dataset for this to the againg dataset

# Fit the model for differential variability, specifying that the four cell types are the groups of interest
fitvar <- varFit(mVals, design = design, coef = c(1,2,3,4))
# Specify the groups we are interested in testing for differential variability
contr <- makeContrasts(naive-rTreg,
                       naive-act_naive,
                       rTreg-act_rTreg,
                       act_naive-act_rTreg,
                       levels=design)
fitvar <- contrasts.varFit(fitvar,contrasts=contr)
# Summary of differential variability
summary(decideTests(fitvar))
topDV <- topVar(fitvar, coef=1)
# Top 10 differentially variable CpGs between naive and rTreg
topDV
```
Just as we had a look at the beta values for the significant differentially methylated CpGs, it is useful to plot differentially variable CpGs too.

```{r, cache=TRUE}
par(mfrow=c(2,2))
sapply(rownames(topDV)[1:4], function(cpg){
  plotCpg(bVals, cpg=cpg, pheno = targets$Sample_Group)
})
```
An example of testing for differential variability when you have a design matrix with an intercept term is detailed in the *missMethyl* [vignette]("http://www.bioconductor.org/packages/release/bioc/vignettes/missMethyl/inst/doc/missMethyl.pdf").



# Software versions
```{r}
sessionInfo()
```